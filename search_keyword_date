import requests
import pandas as pd
from datetime import datetime, timedelta
import xml.etree.ElementTree as ET
import os
import time

# === [설정] 서비스 키 입력 ===
SERVICE_KEY = ""


class G2BAPIClient:
    def __init__(self, service_key):
        self.base_url = "http://apis.data.go.kr/1230000/ad/BidPublicInfoService/getBidPblancListInfoThngPPSSrch"
        self.service_key = service_key

    def fetch_bid_notices(self, search_params):
        """API 1회 호출"""
        params = {
            'ServiceKey': self.service_key,
            'numOfRows': search_params.get('numOfRows', 100),
            'pageNo': search_params.get('pageNo', 1),
            'inqryDiv': search_params.get('inqryDiv', '1'),
            'inqryBgnDt': search_params['inqryBgnDt'],
            'inqryEndDt': search_params['inqryEndDt']
        }

        # 나라장터 API 자체 검색 시 띄어쓰기가 포함된 키워드로 검색할 경우
        if 'bidNtceNm' in search_params and search_params['bidNtceNm']:
            params['bidNtceNm'] = search_params['bidNtceNm']

        try:
            response = requests.get(self.base_url, params=params, timeout=30)
            if response.status_code != 200:
                print(f"  [HTTP 오류] {response.status_code}")
                return []

            root = ET.fromstring(response.content)
            result_code = root.find('.//resultCode')
            result_code_text = result_code.text if result_code is not None else None

            if result_code_text != '00':
                result_msg_node = root.find('.//resultMsg')
                result_msg = result_msg_node.text if result_msg_node is not None else "알 수 없는 오류"

                if "조회된 데이터가 없습니다" in result_msg:
                    return []
                print(f"  [API 메시지] {result_msg}")
                return []

            items = root.findall('.//item')
            return self._parse_items(items)

        except Exception as e:
            print(f"  [시스템 오류] {e}")
            return []

    def _parse_items(self, items):
        result = []
        for item in items:
            data = {
                'bidNtceNo': self._get_text(item, 'bidNtceNo'),
                'rgstTyNm': self._get_text(item, 'rgstTyNm'),
                'ntceKindNm': self._get_text(item, 'ntceKindNm'),
                'bidNtceDt': self._get_text(item, 'bidNtceDt'),
                'bidNtceNm': self._get_text(item, 'bidNtceNm'),
                'ntceInsttNm': self._get_text(item, 'ntceInsttNm'),
                'dminsttNm': self._get_text(item, 'dminsttNm'),
                'ntceInsttOfclNm': self._get_text(item, 'ntceInsttOfclNm'),
                'ntceInsttOfclTelNo': self._get_text(item, 'ntceInsttOfclTelNo'),
                'bidClseDt': self._get_text(item, 'bidClseDt'),
                'opengDt': self._get_text(item, 'opengDt')
            }
            result.append(data)
        return result

    def _get_text(self, item, tag_name):
        element = item.find(tag_name)
        return element.text if element is not None and element.text else ''

    def fetch_all_pages(self, search_params):
        """페이징 처리"""
        all_data = []
        page_no = 1
        num_of_rows = search_params.get('numOfRows', 100)

        while True:
            search_params['pageNo'] = page_no
            data = self.fetch_bid_notices(search_params)

            if not data:
                break

            all_data.extend(data)
            # 가져온 데이터 개수가 numOfRows보다 작으면 마지막 페이지로 간주
            if len(data) < num_of_rows:
                break
            page_no += 1
            time.sleep(0.1)  # API 부하 방지용 짧은 대기

        return all_data


def get_user_date_ranges():
    """사용자로부터 날짜를 입력받아 API 요구 형식으로 변환하고 월 단위로 나눕니다."""
    while True:
        try:
            start_str = input("조회 시작일을 입력하세요 (예: 2025-12-12): ").strip()
            end_str = input("조회 마감일을 입력하세요 (예: 2026-01-01): ").strip()

            start_date = datetime.strptime(start_str, "%Y-%m-%d")
            # 마감일은 해당 일자의 23시 59분으로 설정
            end_date = datetime.strptime(end_str, "%Y-%m-%d").replace(hour=23, minute=59)

            if start_date > end_date:
                print("시작일이 마감일보다 늦을 수 없습니다. 다시 입력해주세요.\n")
                continue

            # 검색 기간이 미래일 경우를 방지 (필요 시 주석 처리 가능)
            if start_date > datetime.now():
                print("시작일은 오늘 또는 과거여야 합니다. 다시 입력해주세요.\n")
                continue

            break
        except ValueError:
            print("날짜 형식이 올바르지 않습니다. YYYY-MM-DD 형식으로 다시 입력해주세요.\n")

    ranges = []
    current_start = start_date

    # API 검색 기간 제한이나 부하를 방지하기 위해 30일 단위로 끊어서 요청
    while current_start < end_date:
        current_end = current_start + timedelta(days=29, hours=23, minutes=59)

        if current_end > end_date:
            current_end = end_date

        # API 요구 포맷: YYYYMMDDHHMM
        str_start = current_start.strftime('%Y%m%d%H%M')
        str_end = current_end.strftime('%Y%m%d%H%M')

        ranges.append((str_start, str_end))
        current_start = current_end + timedelta(minutes=1)

    return ranges, start_str, end_str


def get_user_keywords():
    """사용자로부터 쉼표로 구분된 키워드를 입력받습니다."""
    while True:
        k_input = input("\n검색할 키워드를 쉼표(,)로 구분하여 입력하세요 (예: 서버, gpu, 워크스테이션): ").strip()
        if not k_input:
            print("키워드를 하나 이상 입력해야 합니다.")
            continue

        # 쉼표 기준으로 나누고 각 키워드의 앞뒤 공백 제거
        keywords = [k.strip() for k in k_input.split(',')]
        # 빈 문자열 제거
        keywords = [k for k in keywords if k]

        if keywords:
            return keywords
        else:
            print("유효한 키워드를 입력해주세요.")


def save_to_excel(df, start_str, end_str):
    if df.empty:
        print("저장할 데이터가 없습니다.")
        return

    col_map = {
        'bidNtceNo': '공고번호',
        'rgstTyNm': '등록유형',
        'ntceKindNm': '공고종류',
        'bidNtceDt': '공고일시',
        'bidNtceNm': '공고명',
        'ntceInsttNm': '공고기관',
        'dminsttNm': '수요기관',
        'ntceInsttOfclNm': '담당자',
        'ntceInsttOfclTelNo': '전화번호',
        'bidClseDt': '마감일시',
        'opengDt': '개찰일시'
    }

    save_df = df[list(col_map.keys())].rename(columns=col_map)

    # 엑셀 파일명 생성 (사용자가 입력한 기간 포함)
    filename = f'입찰공고_검색결과_{start_str}_to_{end_str}.xlsx'

    try:
        save_df.to_excel(filename, index=False)
        print(f"\n[성공] 엑셀 저장 완료: {filename}")
        print(f"총 공고 수: {len(save_df)}건")
    except PermissionError:
        print(f"\n[오류] '{filename}' 파일이 이미 열려있습니다. 파일을 닫고 다시 실행해주세요.")
    except Exception as e:
        print(f"\n[오류] 엑셀 저장 중 문제가 발생했습니다: {e}")


def main():
    print("=== 나라장터 공고 검색 시스템 ===")

    # 1. 사용자로부터 검색 기간 입력받기
    date_ranges, start_str, end_str = get_user_date_ranges()

    # 2. 사용자로부터 검색 키워드 입력받기
    target_keywords = get_user_keywords()

    client = G2BAPIClient(SERVICE_KEY)
    print(f"\n조회 기간: {start_str} ~ {end_str}")
    print(f"검색 키워드: {', '.join(target_keywords)}")
    print("데이터 수집을 시작합니다...\n")

    all_results = []

    for keyword in target_keywords:
        print(f"--- '{keyword}' 데이터 수집 중 ---")

        keyword_results = []

        # 날짜 범위가 길 경우 나누어서 호출 (API 정책 대응)
        for start_dt, end_dt in date_ranges:
            params = {
                'inqryDiv': '1',
                'inqryBgnDt': start_dt,
                'inqryEndDt': end_dt,
                'numOfRows': 100,
                # API 파라미터로 키워드를 넘겨 1차 필터링 (선택 사항이나 효율을 위해 유지)
                'bidNtceNm': keyword
            }

            results = client.fetch_all_pages(params)
            if results:
                keyword_results.extend(results)

        # 3. 가져온 데이터에 대해 띄어쓰기를 무시하고(LIKE 검색처럼) 2차 필터링
        if keyword_results:
            # 검색 키워드의 모든 공백 제거
            stripped_target_keyword = keyword.replace(" ", "")
            filtered_results = []

            for item in keyword_results:
                bid_name = item.get('bidNtceNm', '')
                if bid_name:
                    # 공고명 원문의 모든 공백을 제거한 후 비교
                    stripped_bid_name = bid_name.replace(" ", "")
                    # 띄어쓰기가 무시된 상태에서 키워드가 포함되어 있는지 확인 (대소문자 무시)
                    if stripped_target_keyword.lower() in stripped_bid_name.lower():
                        filtered_results.append(item)

            if filtered_results:
                all_results.extend(filtered_results)
                print(f"  > 필터링 완료: {len(filtered_results)}건 발견")
            else:
                print(f"  > 조건에 맞는 데이터 없음")
        else:
            print(f"  > API 조회 결과 없음")

    # 4. 최종 결과 병합, 중복 제거 및 저장
    if all_results:
        df = pd.DataFrame(all_results)

        # 공고번호 기준 중복 제거 (여러 키워드에 동시에 걸린 공고 처리)
        df_unique = df.drop_duplicates(subset=['bidNtceNo'])
        print(f"\n[최종 집계] 중복 제거 후 총 {len(df_unique)}건의 공고가 추출되었습니다.")

        save_to_excel(df_unique, start_str, end_str)
    else:
        print("\n입력하신 조건으로 조회된 공고가 없습니다.")


if __name__ == "__main__":
    main()
